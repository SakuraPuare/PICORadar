# 开发日志 #6：健壮性工程——构建具备自愈能力的系统基石

**作者：书樱**
**日期：2025年7月21日**

> **摘要**: 本文记录了一次从解决测试不稳定性问题，到最终实现系统级自愈能力的深度工程探索。我们将剖析测试非确定性（Test Flakiness）的根源，并阐述如何通过严格的“测试隔离”原则来解决它。更进一步，我们将深入探讨“面向失败设计”的哲学，展示如何通过跨平台的进程检查和严谨的状态逻辑，赋予系统在面对异常崩溃时清理“陈旧锁”的自我修复能力，从而铸就坚不可摧的程序健壮性。

---

大家好，我是书樱。

在软件工程的实践中，真正的成长往往源于对“失败”的深入剖析。今天，我想分享的故事，就是一次由测试失败引发的、对PICO Radar项目健壮性的深度重构。它引领我们超越了“让代码能跑”，迈向了“让代码在异常情况下依然可靠”的新境界。

### 第一幕：测试的非确定性 (Test Flakiness)

在我们为`SingleInstanceGuard`（确保服务器单实例运行的模块）编写了自动化测试后，CI流水线上出现了一个棘手的“幽灵”：测试用例时而通过，时而因`bind: Address already in use`错误而超时失败。

我们最初的诊断指向了资源竞争。`ctest`可能会并行执行多个需要绑定网络端口的测试。然而，即便我们强制测试串行执行，问题依然存在。原因是TCP协议的`TIME_WAIT`状态——前一个测试释放的端口，在操作系统层面并不会被立即回收。

这暴露了我们测试套件的一个根本性缺陷：**非确定性 (Non-determinism)**。一个依赖于外部时序和运气的测试，其价值几乎为零，因为它无法提供可靠的质量反馈。

### 第二幕：原则的确立——测试隔离

我们意识到，任何试图通过“等待”或“重试”来规避资源竞争的方案，都只是治标不治本。根本性的解决方案是确立并执行一条黄金法则：**测试隔离 (Test Isolation)**。

**每一个集成测试，都必须在自己独立的、受控的资源环境中运行。**

为此，我们对项目进行了两项关键改造：
1.  **服务器端口参数化**: 我们修改了`server`，使其可以从命令行接收端口号，取代了硬编码的端口。
2.  **测试脚本的显式配置**: 我们的每一个集成测试脚本（`run_*.sh`）现在都会为服务器和客户端指定一个唯一的、专用的端口号（如9003, 9004, 9005...）。

通过这一改造，我们彻底根除了测试之间的资源竞争，确保了测试结果的100%确定性。CI流水线终于稳定地全线飘绿。

### 第三幕：从测试健壮性到程序健壮性

此时，一个更深刻的问题被提出：“我们只是让*测试*变得健-壮了。但服务器*程序本身*在真实世界中足够健壮吗？如果服务器异常崩溃，留下一个‘僵尸’锁文件，它岂不是永远无法再次启动了？”

这是一个直击灵魂的拷问，它迫使我们从“假设程序正常运行”的思维，转向“**面向失败设计 (Design for Failure)**”的哲学。我们必须假定程序会崩溃，并为这种失败场景设计恢复机制。

我们的目标是：赋予`SingleInstanceGuard`**自我修复（Self-Healing）** 的能力。

#### 核心武器：跨平台进程存在性检查

要安全地删除一个“陈旧”的锁文件，我们必须首先确认创建该锁的进程确实已经死亡。为此，我们实现了一个跨平台的辅助函数`is_process_running(pid)`。

-   **POSIX (Linux, macOS) 实现**:
    ```cpp
    // kill(pid, 0) 是一个高效且符合POSIX标准的技巧。
    // 它不发送任何信号，而是利用系统调用的返回值来检查进程是否存在。
    // 返回0表示进程存在，返回-1且errno为ESRCH表示进程不存在。
    // 我们还处理了EPERM的情况，即进程存在但我们无权访问。
    return (kill(pid, 0) == 0 || errno == EPERM);
    ```
-   **Windows 实现**:
    ```cpp
    // 在Windows上，我们通过尝试获取进程句柄来判断其是否存在。
    // 即使只请求最基本的同步权限，只要能成功打开句柄，就意味着进程存在。
    HANDLE process = OpenProcess(SYNCHRONIZE, FALSE, pid);
    if (process != NULL) {
        CloseHandle(process); // 成功获取后立即释放
        return true;
    }
    return false;
    ```

#### 终极进化：具备自愈能力的`SingleInstanceGuard`

装备了`is_process_running`后，我们重写了`SingleInstanceGuard`的构造函数，其逻辑状态机如下：
1.  **尝试获取锁**: 尝试以原子方式创建并锁定文件。
2.  **若成功**: 锁定成功，将当前进程PID写入锁文件。程序正常继续。
3.  **若失败**: 锁文件已存在。读取文件中的`old_pid`。
4.  **检查`old_pid`**: 调用`is_process_running(old_pid)`。
5.  **若`old_pid`仍在运行**: 确实有另一个实例正在运行。抛出异常，阻止程序启动。
6.  **若`old_pid`已死亡**: 这是一个“陈旧锁”。**执行自愈操作**：安全地删除该锁文件。
7.  **再次尝试获取锁**: 重复步骤1。如果这次成功，则正常继续。如果再次失败（可能因为其他进程在纳秒间抢先了），则抛出异常。

这个逻辑闭环，确保了我们的服务器即使在经历硬崩溃后，也能够在下次启动时自动清理现场，恢复正常。

### 结语：工程闭环的形成

为了验证这一自愈机制，我们编写了专属的`StaleLockTest`，它会故意制造一个陈旧锁，并断言程序能够成功启动。这个测试的通过，标志着我们完成了一次完美的工程闭环：发现问题 -> 制定原则 -> 设计方案 -> 实现代码 -> 编写测试验证方案。

这次“绕道”极大地强化了PICO Radar的可靠性。我们没有选择绕过问题，而是直面它、分析它、并从根本上解决了它。现在，站在这坚不可摧的基石之上，我们对项目的未来充满了前所未有的信心。

下一站，核心功能，我们来了！

感谢您的耐心与陪伴，我们下次见！

---
书樱
2025年7月21日
