# 开发日志#2：TDD的胜利——构建坚如磐石的核心逻辑

**作者：书樱**
**日期：2025年7月21日**

> **摘要**: 在搭建好脚手架后，我们终于写下了PICO Radar项目的第一行功能代码。但我们没有直接去碰复杂的网络部分，而是从最核心、最纯粹的“玩家状态管理”模块开始。更重要的是，我们为它配备了强大的“质量装甲”——单元测试。这篇文章将分享我们是如何通过测试驱动开发（TDD）的理念，确保每一行核心代码都坚如磐石。

---

大家好，我是书樱。

在经历了与依赖管理的艰苦战斗后，我们终于迎来了一个令人振奋的时刻：编写真正的功能代码。

一个常见的诱惑是立即开始写网络服务器——毕竟，这听起来最酷。但我们抵制了这个诱惑，并选择了一条更稳健、更专业的道路：**从核心逻辑开始，并用测试来驱动它**。

### 关注点分离：`core`模块的诞生

我们的设计哲学是“高内聚、低耦合”。这意味着，管理玩家状态的核心逻辑（谁在线？他们的位置在哪？）不应该关心这些数据是通过WebSocket、HTTP还是信鸽传递过来的。它只负责管理一个内存中的列表。

为此，我们创建了`src/core`模块，并在其中定义了我们的第一个C++类：`PlayerRegistry`。

这个类的职责非常纯粹和专一：
-   `updatePlayer()`: 添加一个新玩家，或者更新一个老玩家的数据。
-   `removePlayer()`: 移除一个玩家。
-   `getAllPlayers()`: 获取当前所有玩家的列表快照。

为了应对未来服务器多线程处理客户端请求的场景，我们从第一天起就为`PlayerRegistry`的每一个公共方法都加上了`std::mutex`锁，确保其**线程安全**。这是一个至关重要的设计决策，它能从根本上避免未来可能出现的、极难调试的并发问题。

### 先写测试，再写代码

在实现`PlayerRegistry`的具体逻辑之前，我们先做了另一件事：**为它编写测试**。

这就是测试驱动开发（TDD）的核心思想。我们没有直接去实现`updatePlayer`，而是先问自己：“一个正确的`updatePlayer`应该表现出什么样的行为？”

我们使用GoogleTest框架，在`test/core_tests`目录下创建了`test_player_registry.cpp`，并定义了一系列清晰的测试用例（Test Case）：

-   `InitialState`: 一个新创建的`PlayerRegistry`应该是空的。
-   `AddSinglePlayer`: 添加一个玩家后，总数应该变为1，并且能根据ID取回正确的数据。
-   `UpdateExistingPlayer`: 对同一个ID更新数据，总数不应改变，但数据应该被覆盖。
-   `RemovePlayer`: 移除一个玩家后，总数应该减少，并且再也找不到这个玩家。
-   `RemoveNonExistentPlayer`: 移除一个不存在的玩家，程序不应崩溃，总数也不应改变。

### 红灯 -> 绿灯：TDD的节奏

当我们写完测试框架但还没有实现功能代码时，运行测试，所有测试都会失败——这就是“红灯”。

然后，我们回到`player_registry.cpp`中，用最简洁、最高效的代码（比如使用`std::unordered_map`来实现O(1)的平均查找效率）去实现功能，目标就是让所有测试用例通过。

当我们再次运行`ctest --verbose`时，奇迹发生了。屏幕上输出了一连串的`[ OK ]`和`Passed`。

```
100% tests passed, 0 tests failed out of 6
```

这就是“绿灯”。这个绿灯不仅仅意味着代码能运行，它更是一个强有力的**质量声明**：我们的`PlayerRegistry`模块，在其所有公开的功能点上，其行为都与我们的预期**完全一致**。

### 结语：自信的基石

通过优先编写测试，我们不仅验证了代码的正确性，更为未来的开发建立了强大的信心。现在，无论未来我们如何重构`PlayerRegistry`的内部实现（比如为了性能优化更换数据结构），只要我们能保证这套测试依然100%通过，我们就能确信，我们的修改没有破坏任何已有的功能。

这个经过测试验证的`core_logic`库，就是我们构建整个PICO Radar服务器的、第一块坚实可靠的基石。

现在，有了这个稳定的核心，我们终于可以安心地去探索网络编程的星辰大海了。
