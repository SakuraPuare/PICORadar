# 开发日志 #7：可靠性史诗——征服并发、泄漏与协议死锁

**作者：书樱**
**日期：2025年7月21日**

> **摘要**: 本文深入记录了PICO Radar项目在实现核心广播功能时，为达到工业级可靠性而进行的一次深度质量重构。我们将系统性地剖析并解决三大挑战：因身份管理不当导致的资源泄漏、因误用异步模型导致的并发冲突、以及因未完全遵从协议导致的客户端死锁。这是一个关于如何通过严格的代码审查、对底层原理的深刻理解和健壮的自动化测试，将一个“能用”的系统锻造成“可靠”的产品的工程史诗。

---

大家好，我是书樱。

在软件开发的旅程中，功能的实现往往只是第一步。真正的挑战在于，如何确保这些功能在真实世界的复杂与混乱中，依然能够坚如磐石地可靠运行。今天，我将分享PICO Radar项目在实现核心“数据广播”功能时，所经历的一次深刻的“成人礼”。

它始于一个看似简单的问题：“我们的实现是最佳实践吗？”，最终演变为一场与资源泄漏、并发冲突和协议死锁的全面战争。

### 第一章：资源泄漏——身份管理的缺陷

在对初步完成的广播功能进行代码审查时，我们发现了第一个严重缺陷：当一个客户端断开连接后，其代表的玩家数据会永久地残留在服务器内存中，形成一个无法被清理的“幽灵玩家”。

-   **根本原因**: 这个问题的根源在于**会话（Session）生命周期与玩家身份（Player ID）生命周期的错误耦合**。我们最初的设计中，`Session`对象在析构时，并不知道它所服务的、经过认证的玩家的真实ID，导致它无法通知`PlayerRegistry`去正确地移除玩家状态。
-   **解决方案：认证即身份**: 我们确立了一条核心设计原则：**客户端的身份必须在认证（Authentication）阶段被唯一确立，并贯穿整个会话（Session）的生命周期**。
    1.  **协议强化**: 我们修改了`player_data.proto`，要求`AuthRequest`消息必须包含`player_id`字段。这使得身份成为认证请求的固有部分。
    2.  **逻辑修正**: 服务器的`Session`对象现在只在成功验证令牌后，才会从`AuthRequest`中获取并存储`player_id`。这个ID将伴随`Session`直到其销毁，届时它将被用于精确地清理`PlayerRegistry`中的对应条目。

这次修复，从根本上解决了资源泄漏问题，保证了服务器状态的长期一致性。

### 第二章：并发冲突——对异步模型的误解

解决了内存泄漏后，我们为广播功能编写的集成测试`BroadcastTest`却依然失败，并伴随着来自Boost.Beast底层的断言崩溃。这是一个典型的并发问题，但其根源比传统的数据竞争更为微妙。

-   **Beast/Asio的铁律**: Boost.Asio为每一个I/O对象（如socket）提供了一个隐式的`strand`。这意味着，对于同一个socket，所有的完成处理器（completion handlers）都会在一个单线程的上下文中被串行调用，天然地避免了对共享数据（如socket本身）的竞争。
-   **问题的本质：异步逻辑流竞争**: 我们的错误在于，违反了Beast的**异步操作链模型**。该模型规定：对于一个socket，在任何时刻，最多只能有一个“在途的（in-flight）”读操作和最多一个“在途的”写操作。我们最初的代码，可能会在处理接收数据的回调中，和处理发送完成的回调中，**并发地**为同一个socket发起新的`async_read`操作。这并非数据竞争，而是**异步逻辑流的竞争**，它破坏了Beast内部状态机的假设。
-   **解决方案：严格的单向事件循环**: 我们重构了`Session`的事件处理逻辑，使其遵循一个严格的、无冲突的单向链条：
    1.  连接建立后，发起第一次`async_read`。
    2.  `on_read`回调处理完业务逻辑后，**不再**发起下一次读取。
    3.  当需要写入数据时，通过`async_write`发起写操作。
    4.  在`on_write`回调中，当所有待写数据都发送完毕后，才安全地发起下一次`async_read`。

    这个`Read -> Process -> Write -> Read`的循环，确保了任何时候都只有一个“在途的”读请求，从而与Beast的异步模型完全兼容。

### 第三章：协议死锁——对WebSocket关闭握手的忽视

在我们解决了服务器端的并发问题后，`BroadcastTest`依然失败。这次，服务器安然无恙，但测试客户端`mock_client`却被卡住，直至超时。

-   **WebSocket关闭握手 (Closing Handshake)**: 根据RFC 6455，WebSocket的关闭是一个需要双方确认的**双向握手过程**。一方发送`close`帧，另一方必须回送一个`close`帧作为响应。
-   **死锁分析**: 我们的`mock_client`在发送完数据后，调用了阻塞的`ws.close()`。它正确地发送了`close`帧，然后就进入阻塞状态，等待服务器的响应。然而，由于它已经停止了对socket的读取，因此它**永远无法接收到**服务器回送的`close`帧。这是一个经典的、由于**半双工操作**（只写不读）导致的**协议级死锁**。
-   **解决方案：遵从协议的优雅关闭**: 我们重写了客户端的关闭逻辑，以正确地完成这个“关闭之舞”：
    ```cpp
    // 1. 发起非阻塞的关闭请求
    ws_.async_close(websocket::close_code::normal, ...);
    
    // 2. 在一个循环中持续调用 io_context::run() 或 read()
    //    直到收到对方的close帧，此时read操作会抛出
    //    websocket::error::closed异常，表示握手成功。
    ```

### 结语：凤凰涅槃

当`ctest`的输出最终稳定地显示`100% tests passed`时，我们知道，PICO Radar项目经历了一次意义非凡的蜕变。我们收获的不仅是一个能用的广播功能，更是一个无资源泄漏、线程安全、协议兼容、并经过层层自动化测试验证的，真正达到工业级可靠性的核心系统。

更重要的是，我们塑造了项目的工程师文化：对质量刨根问底，对原理深入探究，并用自动化测试来证明一切。站在这坚不可摧的基石上，我们对未来充满了前所未有的信心。

感谢您的耐心与陪伴，我们下次见！

---
书樱
2025年7月21日
