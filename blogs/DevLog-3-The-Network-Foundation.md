# DevLog #3: 奠定网络基石：从核心逻辑到实时服务器

大家好，我是书樱！

在上一篇日志中，我们庆祝了 `PlayerRegistry` 核心逻辑的完成，并通过了严密的单元测试。这感觉很棒，就像我们已经打造好了一台性能强劲的引擎。但是，一台引擎只有被装进车里，连接上轮子，才能真正地驰骋。对我们的PICO Radar项目来说，这意味着要将这个核心“引擎”连接到真实的网络世界中。

今天，我非常激动地想和大家分享，我们已经成功地为这台引擎安装了“传动系统”和“底盘”——一个功能齐全的WebSocket服务器！

## 技术决策的演进：拥抱 Boost.Beast

在最初的计划中，我们考虑使用 `websocketpp` 库。但随着项目的深入，我们进行了一次重要的技术栈升级，最终选择了 **Boost.Beast**。

为什么要做这个改变？

1.  **质量与生态系统**：Boost是C++世界里久经考验的“准标准库”，以其高质量、高性能和稳定性而闻名。将我们的网络层建立在Boost（特别是它底层的Asio）之上，意味着我们站在了巨人的肩膀上。
2.  **现代C++范式**：Boost.Asio是现代C++异步编程的典范，它与我们项目遵循的C++17最佳实践（如回调、lambda、智能指针）完美契合。
3.  **依赖管理**：通过 `vcpkg`，我们可以非常干净利落地管理整个Boost库，避免了复杂的子模块或源码集成。

这个决策提升了我们项目的技术标准，虽然带来了一些学习曲线，但我们坚信这是值得的。

## `main.cpp` 的华丽蜕变

如果你还记得，我们最初的 `main.cpp` 只是一个用于验证Protobuf能否正常工作的简单脚本。现在，它已经“长大成人”，变成了一个真正的服务器应用程序入口。

```cpp
// src/server_app/main.cpp (概念性展示)

int main(int argc, char* argv[]) {
    // ... 初始化 glog 日志 ...
    
    // ... 注册信号处理器，实现优雅停机 ...
    
    // 创建核心模块
    auto registry = std::make_shared<picoradar::core::PlayerRegistry>();

    // 创建并运行网络服务器
    auto server = std::make_shared<picoradar::network::WebsocketServer>(*registry);
    server->run("0.0.0.0", 9002, 4); // 监听所有接口，4个IO线程

    // ... 等待停止信号，然后干净地关闭服务器 ...

    return 0;
}
```

这里有几个关键点值得一提：

*   **优雅停机 (Graceful Shutdown)**：我们实现了一个信号处理器来捕获 `Ctrl+C`。当用户想要关闭服务器时，我们不再是粗暴地终止进程，而是会通知服务器停止接受新连接，完成当前任务，然后干净地释放所有资源。这是一个专业服务器应用的必备素养。
*   **模块化设计**：`main` 函数清晰地展示了我们的架构：创建 `PlayerRegistry` 核心，然后将其“注入”到 `WebsocketServer` 中。服务器负责网络通信，核心负责状态管理，职责分离，非常清晰。
*   **专业日志**：我们集成了 Google 的 `glog` 库。从此，所有的 `std::cout` 都将被结构化的、带级别的日志消息所取代。这对于调试和线上监控至关重要。

## 里程碑达成！

随着 `git diff` 中那片令人满足的绿色，我们正式完成了 `ROADMAP.md` 中一个至关重要的部分。PICO Radar 服务器现在不再是一个抽象的概念，它是一个可以被编译、运行，并真正在网络端口上等待客户端连接的应用程序了！

当然，这只是一个新的开始。服务器虽然在运行，但它还不会验证客户端身份，也不会广播玩家数据。

接下来的任务是：
1.  实现基于Token的身份验证。
2.  构建数据广播循环。
3.  开发一个模拟客户端 (`mock_client`) 来真正地测试我们的服务器。

每一步都充满挑战，但也同样令人兴奋。感谢大家的一路关注，我们下次更新再见！

---
书樱
2025年7月21日