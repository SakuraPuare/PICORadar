# 开发日志 #1：构建系统与依赖管理策略的演进

**作者：书樱**
**日期：2025年7月21日**

> **摘要**: 本文记录了PICO Radar项目构建系统从零到一的搭建过程，并深入探讨了C++依赖管理中不同策略的权衡。我们将分析项目级依赖管理器（vcpkg）与CMake原生模块（FetchContent）的优劣，并展示在面对上游技术债时，如何通过务实的“引入并修补”（Vendor-and-Patch）策略，最终构建出一个健壮、可复现且灵活的混合式依赖管理架构。

---

大家好，我是书樱。

在上一篇日志中，我们为PICO Radar绘制了详尽的架构蓝图。今天，我们将从抽象的设计走向具象的实现。在软件工程中，这第一步并非编写业务逻辑，而是构筑一个坚实的“脚手架”——一个能够自动化编译、链接、并精确管理所有外部代码的构建系统。

对于C++而言，这片领域充满了挑战与决策。

### 奠基：目录结构与现代CMake

我们首先按照`README.md`中的规划，建立了清晰的目录结构 (`src`, `test`, `proto`等)。这种分离不仅是物理上的，更是逻辑上的，它强制我们思考模块间的边界。

紧接着，我们为项目编写了`CMakeLists.txt`文件。我们全面拥抱**现代CMake**的最佳实践：
- **基于目标（Target-based）的思维**: 我们使用`add_library`和`add_executable`定义了多个目标（如`core_logic`, `network_lib`, `server_app`）。
- **属性封装**: 所有的编译选项、包含目录和链接库都通过`target_compile_features`, `target_include_directories`, `target_link_libraries`等命令与特定目标绑定。这取代了旧式的、基于全局变量的配置方式，极大地提高了模块的封装性和可重用性。

### 依赖管理哲学：为何选择vcpkg？

C++的依赖管理存在两大流派：
1.  **系统级包管理器**: 如Linux的`apt`、`pacman`，或macOS的`brew`。它们易于使用，但通常一个系统只能安装一个版本，难以满足多项目对不同依赖版本的需求。
2.  **项目级依赖管理器**: 如`vcpkg`, `Conan`。它们将依赖项下载并构建在项目本地，实现了项目间依赖的完全隔离。

我们毫不犹豫地选择了后者，并具体采用了**vcpkg**。其最吸引我们的特性是它的**清单模式（Manifest Mode）**：
-   我们只需在项目根目录创建一个`vcpkg.json`文件，以声明式的方式列出所有依赖（`protobuf`, `gtest`, `boost-beast`等）。
-   在运行CMake时，通过`-DCMAKE_TOOLCHAIN_FILE`指向vcpkg的脚本，它便会自动处理所有依赖的下载、编译和集成，实现了真正的“一键式可复现构建”。

### 第一次挑战：当生态系统出现缺口

我们将最初选定的`websocketpp`库加入`vcpkg.json`，满怀信心地运行CMake，却收到了一个错误：vcpkg的官方仓库中没有提供`websocketpp`的元数据。

这暴露了任何生态系统都可能存在的问题：覆盖范围并非无限。我们面临第一个决策点：是替换掉`websocketpp`，还是为它寻找另一条集成路径？考虑到`websocketpp`的成熟度，我们选择了后者。

### 第二次尝试：CMake原生的`FetchContent`

我们转向了CMake 3.11+ 提供的原生解决方案：`FetchContent`模块。它允许CMake在配置阶段（configure-time）直接从Git仓库或其他源下载代码，并将其“内联”到我们的主构建树中。

相比于vcpkg，`FetchContent`更轻量，不依赖外部工具。我们修改`CMakeLists.txt`，声明从`websocketpp`的官方GitHub仓库获取代码。

然而，新的问题出现了：`websocketpp`项目本身的`CMakeLists.txt`过于陈旧，它要求的CMake最低版本（2.8.8）与我们正在使用的现代CMake（3.20+）产生了兼容性冲突。这是典型的**上游技术债**问题。

### 最终方案：“引入并修补” (Vendor-and-Patch)

在尝试了多种通过CMake策略（Policy）进行兼容的“优雅”方案失败后，我们采取了一种在工程实践中非常常见且务实的策略：“**Vendor-and-Patch**”。

这个策略的逻辑是：我们将第三方代码视为项目的一部分（Vendor），并在其基础上打上我们自己的补丁（Patch）。

我们的自动化流程演变为：
1.  在CMake中，我们仍然使用`FetchContent`来自动拉取`websocketpp`的源码到`build/_deps`目录。
2.  我们编写了一个简单的脚本，在CMake配置步骤之后、构建步骤之前，**自动地**对下载下来的`websocketpp`的`CMakeLists.txt`文件进行修改，将其`cmake_minimum_required`版本提升到兼容的`3.5`。
3.  执行构建。

这个方案的优点是：
-   **自动化**: 整个过程无需手动干预，对开发者透明。
-   **隔离性**: “补丁”操作被严格限制在构建目录内，不污染原始的`FetchContent`缓存或项目源码。
-   **实用性**: 它解决了问题。在理想主义和现实主义之间，我们选择了后者。

### 结语：一个健壮的混合式依赖架构

至此，PICO Radar的脚手架宣告完成。我们最终形成了一个健壮的、混合式的依赖管理架构：
-   **vcpkg为主**: 负责所有主流、维护良好、且符合vcpkg生态的库。它提供了最佳的自动化和集成体验。
-   **FetchContent + Patch为辅**: 负责处理那些有历史遗留问题或不在vcpkg生态中的“长尾”依赖。

这段经历虽然曲折，但它迫使我们深入理解了现代C++构建系统的复杂性与权衡艺术。我们打造的地基，不仅能支撑起PICO Radar，更能应对未来任何复杂的依赖挑战。

现在，钢筋骨架已就位。下一篇，我们将开始浇筑第一块混凝土——实现系统的核心业务逻辑。

下次见！

—— 书樱